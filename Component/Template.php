<?php

/**
 * Template
 *
 * Generates markup for display based on a set of input values
 *
 * Template subclasses are intended to work as a kind of fixed contract between
 * frontend and backend code. This is intended to help minimise the occurrence
 * of easily-missed bugs caused by E_NOTICE errors hidden away in attributes of
 * HTML tags.
 *
 * @abstract
 * @author     Henry Smith <henry@henrysmith.org> 
 * @copyright  2010 - 2011 Henry Smith
 * @license    GPLv2.0
 * @package    Tree
 * @subpackage Component
 * @version    0.02
 */

namespace Tree\Component;

use \Tree\Exception\TemplateException;

abstract class Template {

	/**
	 * An associative array mapping names of optional input values to
	 * defaults for those values
	 * 
	 * @access protected
	 * @var    array
	 */
	protected $optionalInputValues = array();

	/**
	 * An array listing required input values without which the template
	 * must not attempt to generate markup
	 * 
	 * @access protected
	 * @var    array
	 */
	protected $requiredInputValues = array();

	/**
	 * The name of the template file from which output is to be generated 
	 * 
	 * @access protected
	 * @var    string
	 */
	protected $templateFilename;

	/**
	 * An associative array of actual input values 
	 * 
	 * @access private
	 * @var    array
	 */
	private $inputValues = array();

	/**
	 * The string generated by the last invocation of generateMarkup()
	 * 
	 * @access private
	 * @var    string
	 */
	private $outputString;

	public function __construct()
	{
		$this->inputValues = $this->optionalInputValues;
	}

	/**
	 * Returns the output of the template if all required input values
	 * are available
	 * 
	 * @access public
	 * @param  boolean $regenerate [optional]  Whether the output generated by previous invocation should be disregarded
	 * @return string
	 */
	public function getOutput($regenerate = false)
	{
		if ($regenerate === false && $this->outputString !== null) {
			return $this->outputString;
		}

		$this->outputString = $this->generateOutput();

		return $this->outputString;
	}

	/**
	 * Stores an input value to be used by the template 
	 *
	 * Throws an exception if the name of the value given is not a valid
	 * one for this template.
	 * 
	 * @access public
	 * @param  string $name 
	 * @param  mixed  $value 
	 */
	public function setInputValue($name, $value)
	{
		if (!$this->isPermissibleValue($name)) {
			$message = "Invalid template value: {$name}";
			$code    = TemplateException::INVALID_VALUE_NAME;
			throw new TemplateException($message, $code);
		}

		$this->inputValues[$name] = $value;
	}

	/**
	 * Sets the name of the template file to use when generating output 
	 *
	 * The filename given should either be a file in PHP's include_path or
	 * an absolute filename.
	 * 
	 * @access public
	 * @param  string $templateFilename 
	 */
	public function setTemplateFilename($templateFilename)
	{
		$this->templateFilename = $templateFilename;
	}

	/**
	 * Generates the output string provided that all the required input
	 * values are available
	 *
	 * Throws an exception if required input is missing or if no template
	 * filename has been set.
	 * 
	 * @access private
	 * @return string
	 */
	private function generateOutput()
	{
		if ($this->templateFilename === null) {
			$message = 'No template file specified';
			$code    = TemplateException::MISSING_TEMPLATE_FILENAME;
			throw new TemplateException($message, $code);
		}

		$missingValues = $this->getMissingValues();

		if (!empty($missingValues)) {
			$message = "Missing template values: {$missingValues}";
			$code    = TemplateException::MISSING_REQUIRED_VARIABLE;
			throw new TemplateException($message, $code);
		}

		extract($this->inputValues);

		try {

			ob_start();
			include $this->templateFilename;

		} catch (Exception $e) {

			// inspired by Kohana_View's method of cleanly handling
			// errors that occur during output phases
			ob_end_clean();
			throw $e;

		}

		$output = ob_get_clean();

		return $output;

	}

	/**
	 * Returns an array listing the names of any required input values that
	 * have not yet been set
	 * 
	 * @access private
	 * @return array
	 */
	private function getMissingValues()
	{
		$valuesProvided = array_keys($this->inputValues);
		$valuesRequired = $this->requiredInputValues;
		$valuesMissing  = array_diff($valuesRequired, $valuesProvided);

		return $valuesMissing;
	}

	/**
	 * Indicates whether the given input value name is a valid one for this
	 * template
	 *
	 * To be valid it must either be the name of a required value or an
	 * optional value.
	 * 
	 * @access private
	 * @param  string $name 
	 * @return boolean
	 */
	private function isPermissibleValue($name)
	{
		$optionalNames = array_keys($this->optionalInputValues);
		$requiredNames = $this->requiredInputValues;

		$permissibleNames = array_merge(
			$optionalNames,
			$requiredNames
		);

		return in_array($name, $permissibleNames);
	}

}

