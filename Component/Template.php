<?php

/**
 * Template
 *
 * Generates markup for display based on a set of input values
 *
 * Template subclasses are intended to work as a kind of fixed contract between
 * frontend and backend code. This is intended to help minimise the occurrence
 * of easily-missed bugs caused by E_NOTICE errors hidden away in attributes of
 * HTML tags.
 *
 * @abstract
 * @author     Henry Smith <henry@henrysmith.org> 
 * @copyright  2011 Henry Smith
 * @license    GPLv2.0
 * @package    Tree
 * @subpackage Component
 * @version    0.02
 */

namespace Tree\Component;

use \Tree\Behaviour\PreTemplateDisplayLogic;
use \Tree\Exception\TemplateException;

abstract class Template {

	/**
	 * An associative array mapping names of optional input values to
	 * defaults for those values
	 * 
	 * @access protected
	 * @var    array
	 */
	protected $optionalInputValues = array();

	/**
	 * An array listing required input values without which the template
	 * must not attempt to generate markup
	 * 
	 * @access protected
	 * @var    array
	 */
	protected $requiredInputValues = array();

	/**
	 * The name of the template file from which output is to be generated 
	 * 
	 * @access protected
	 * @var    string
	 */
	protected $templateFilename;

	/**
	 * An associative array of actual input values 
	 * 
	 * @access private
	 * @var    array
	 */
	private $inputValues = array();

	/**
	 * The string generated by the last invocation of generateMarkup()
	 * 
	 * @access private
	 * @var    string
	 */
	private $outputString;

	/**
	 * An associative array of input values that are common to all templates
	 *
	 * @access private
	 * @var    array
	 */
	private static $globalValues = array();

	/**
	 * The absolute path of the directory containing the template files
	 *
	 * This path should be such that $templateDirectory . DIRECTORY_SEPARATOR .
	 * $templateFilename constitutes a correct absolute path to the template
	 *
	 * If this isn't set, Template will still attempt to find the template file
	 * by scanning the include_path, which may work if PHP is correctly configured
	 * but isn't ideal from a performance point-of-view.
	 *
	 * @access private
	 * @var    array
	 * @static
	 */
	private static $templateDirectory;

	public function __construct()
	{
		$this->inputValues = $this->optionalInputValues;
	}

	/**
	 * Returns the output of the template if all required input values
	 * are available
	 * 
	 * @access public
	 * @param  boolean $regenerate [optional]  Whether the output generated by previous invocation should be disregarded
	 * @return string
	 */
	public function getOutput($regenerate = false)
	{
		if ($regenerate === false && $this->outputString !== null) {
			return $this->outputString;
		}

		$this->outputString = $this->generateOutput();

		return $this->outputString;
	}

	/**
	 * Stores an input value to be used by the template 
	 *
	 * Throws an exception if the name of the value given is not a valid
	 * one for this template.
	 * 
	 * @access public
	 * @param  string $name 
	 * @param  mixed  $value 
	 */
	public function setInputValue($name, $value)
	{
		if (!$this->isPermissibleValue($name)) {
			$message = "Invalid template value: {$name}";
			$code    = TemplateException::INVALID_VALUE_NAME;
			throw new TemplateException($message, $code);
		}

		$this->inputValues[$name] = $value;
	}

	/**
	 * Sets the name of the template file to use when generating output 
	 *
	 * The filename given should either be a file in PHP's include_path or
	 * an absolute filename.
	 * 
	 * @access public
	 * @param  string $templateFilename 
	 */
	public function setTemplateFilename($templateFilename)
	{
		$this->templateFilename = $templateFilename;
	}

	/**
	 * Stores an input value to be used by all template subclasses
	 * 
	 * @access public
	 * @param  string $name 
	 * @param  mixed $value 
	 * @static
	 */
	public static function setGlobalValue($name, $value)
	{
		self::$globalValues[$name] = $value;
	}

	/**
	 * Stores the given directory as the one to look in to find the template
	 * filename as specified by $this->templateFilename
	 * 
	 * @static
	 * @access public
	 * @param  string $directory 
	 */
	public static function setTemplateDirectory($directory)
	{
		self::$templateDirectory = $directory;
	}

	/**
	 * Finds the absolute path of the template from the relative filename in
	 * $this->templateFilename
	 * 
	 * @access private
	 * @return string
	 */
	private function findAbsolutePath()
	{
		if (isset(self::$templateDirectory)) {

			$templateDirectory = self::$templateDirectory;
			$templateDirectory = rtrim($templateDirectory, DIRECTORY_SEPARATOR);

			$absolutePath = $templateDirectory
				. DIRECTORY_SEPARATOR
				. $this->templateFilename;

			return $absolutePath;
		}

		$includePath = get_include_path();
		$includePath = explode(PATH_SEPARATOR, $includePath);

		foreach ($includePath as $path) {

			$path  = rtrim($path, DIRECTORY_SEPARATOR);
			$path .= DIRECTORY_SEPARATOR;

			$absolutePath = $path . $this->templateFilename;

			if (file_exists($absolutePath)) {
				return $absolutePath;
			}

		}

		return null;
	}
	/**
	 * Generates the output string provided that all the required input
	 * values are available
	 *
	 * Throws an exception if required input is missing or if no template
	 * filename has been set.
	 * 
	 * @access private
	 * @return string
	 */
	private function generateOutput()
	{
		if ($this instanceof PreTemplateDisplayLogic) {
			$this->preProcess();
		}

		if ($this->templateFilename === null) {
			$message = 'No template file specified';
			$code    = TemplateException::MISSING_TEMPLATE_FILENAME;
			throw new TemplateException($message, $code);
		}

		$absolutePath = $this->findAbsolutePath();

		if ($absolutePath === null) {
			$message = 'Template file not found';
			$code    = TemplateException::TEMPLATE_NOT_FOUND;
			throw new TemplateException($message, $code);
		}

		if (!is_readable($absolutePath)) {
			$message = "Template not readable";
			$code    = TemplateException::TEMPLATE_NOT_READABLE;
			throw new TemplateException($message, $code);
		}

		$missingValues = $this->getMissingValues();

		if (!empty($missingValues)) {
			$message = "Missing template values: {$missingValues}";
			$code    = TemplateException::MISSING_REQUIRED_VARIABLE;
			throw new TemplateException($message, $code);
		}

		extract(self::$globalValues);
		extract($this->inputValues);

		try {

			ob_start();
			include $absolutePath;

		} catch (Exception $e) {

			// inspired by Kohana_View's method of cleanly handling
			// errors that occur during output phases
			ob_end_clean();
			throw $e;

		}

		$output = ob_get_clean();

		return $output;

	}

	/**
	 * Returns an array listing the names of any required input values that
	 * have not yet been set
	 * 
	 * @access private
	 * @return array
	 */
	private function getMissingValues()
	{
		$valuesProvided = array_keys($this->inputValues);
		$valuesRequired = $this->requiredInputValues;
		$valuesMissing  = array_diff($valuesRequired, $valuesProvided);

		return $valuesMissing;
	}

	/**
	 * Indicates whether the given input value name is a valid one for this
	 * template
	 *
	 * To be valid it must either be the name of a required value or an
	 * optional value.
	 * 
	 * @access private
	 * @param  string $name 
	 * @return boolean
	 */
	private function isPermissibleValue($name)
	{
		$optionalNames = array_keys($this->optionalInputValues);
		$requiredNames = $this->requiredInputValues;

		$permissibleNames = array_merge(
			$optionalNames,
			$requiredNames
		);

		return in_array($name, $permissibleNames);
	}

}

